# This script contains the single cells TCR clonality analysis for the SLE project collaboration.
# The data were generated by M. Raeber, D.P. Caspar and J. Michler. 
# Single cell RNA seq data pre-processing was done by D.P. Caspar and J. Michler.
# Single cell TCR clonality analysis (this script) was done by J. Michler.

# Loading packages
library(rgl)
library(ggforce)
library(Seurat)
library(scRepertoire)
library(airr)
library(tidyverse)
library(patchwork)
library(umap)
library(UpSetR)
library(SeuratData)
library(cowplot)
library(dplyr)
library(data.table)
library(bruceR)
library(ggridges)
library(MetBrewer)
library(openxlsx)
library(fgsea)
library(msigdbr)
library(viridis)
library(pheatmap)
library(grid)
library(gridExtra)
library(ggpubr)
library(ComplexHeatmap)
library(circlize)


# Clearing the environment
rm(list = ls())

# Useful functions
black.axis.text <- function(){theme(axis.text.x=element_text(colour="black"),axis.text.y=element_text(colour="black"))} # For plotting
`%notin%` <- Negate(`%in%`) # Creating a useful operator
center.title <- function(){theme(plot.title = element_text(hjust = 0.5))} # For plotting
Make.stacked.percentage.plot <- function(Seurat.Object, groups.on.Y.axis, groups.in.legend,X.Axis.title,Y.Axis.title,Legend.title,Plot.title){
  colnum.y.axis <- which( colnames(Seurat.Object@meta.data)==groups.on.Y.axis )
  colnum.groups <- which( colnames(Seurat.Object@meta.data)==groups.in.legend )
  df <- as.data.frame(table(Seurat.Object@meta.data[,colnum.y.axis],Seurat.Object@meta.data[,colnum.groups]))
  df <- df %>% group_by(Var1) %>% add_tally(Freq, name = "Cells.per.Y.axis.category")
  df$groups.in.legend.per.Y.axis.category <- 100*round(df$Freq/df$`Cells.per.Y.axis.category`,3)
  df$Var2 <- factor(df$Var2)
  
  p <- ggplot(df, aes(fill=Var2, y=Var1, x=groups.in.legend.per.Y.axis.category)) + 
    geom_bar(position="fill", stat="identity",colour="black")+theme_classic()+ theme(text = element_text(size = 15))+
    labs(x = X.Axis.title, y=Y.Axis.title)+scale_x_continuous(labels=scales::percent)+labs(fill = Legend.title)+
    scale_fill_manual(values=met.brewer("Austria", length(unique(df$Var2))))+ theme(text = element_text(size = 17))+ggtitle(Plot.title)+
    center.title()+black.axis.text()
  plot(p)
  print(df)
}
asterics.function <- function(X){
  if(X>0.05){
    return <- "ns"
  }
  if(X<=0.05){
    return <- "*"
  }
  if(X<=0.01){
    return <- "**"
  }
  if(X<=0.001){
    return <- "***"
  }
  if(X<=0.0001){
    return <- "****"
  }
  return(return)
}
table.to.percentage <- function(x){
  frame <- as.data.frame(x)
  frame$percentages <- round(100*frame$Freq/sum(frame$Freq),2)
  print(frame)
} # Give a table as input

# Setting the working directory. 
# Cellranger output files and preprocessed dataset (handed over from Dominic) can be reached in sub folders here.
setwd("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022")  

########################################################################################################################################################################
# Part 1: Reading in the pre-processed Seurat object and preparation for downstream analysis.
########################################################################################################################################################################
# Loading in pre-processed Seurat object.
# The pre-processed Seurat object was handed over by D.P. Caspar.
# Cell filtering, dataset integration, dimensional reduction and clustering, as well as cell 
# type annotations have been prepared by D.P. Caspar.
Tregs <- readRDS("./Treg Clonality/Tregs_subclustered.rds")

# Generating a sample column (identical to hash.ID)
Tregs@meta.data$sample <- Tregs@meta.data$hash.ID

# Subsetting to relevant metadata columns for downstream analysis.
Tregs@meta.data <- Tregs@meta.data[,c("sample","timepoint","patient_id","Treg_subclusters")]


########################################################################################################################################################################
# Part 2: Preparation of Immcantation Input files (Input files per patient)
########################################################################################################################################################################
# Preparation of one .txt file per patient
# At the moment, the cell barcodes have a prefix identifying the 10x lane (dataset ID). 
# For immcantation this has to be removed. In addition, to make sure to keep the cell barcodes 
# unique, I am adding letters to the beginning of the barcodes of each dataset:
# A -> AA
# B -> GG
# C -> CC
# D -> TT
# E -> AG
# F -> CT
# G -> AC
Immcantation.Input.Barcode.Function <- function(Barcode.Vector){
  i <- 1
  for (i in 1:length(Barcode.Vector)) {
    if(substr(Barcode.Vector[i],1,2)=="A_"){
      Barcode.Vector[i] <- paste0("AA",substr(Barcode.Vector[i],3,20))
    }
    if(substr(Barcode.Vector[i],1,2)=="B_"){
      Barcode.Vector[i] <- paste0("GG",substr(Barcode.Vector[i],3,20))
    }
    if(substr(Barcode.Vector[i],1,2)=="C_"){
      Barcode.Vector[i] <- paste0("CC",substr(Barcode.Vector[i],3,20))
    }
    if(substr(Barcode.Vector[i],1,2)=="D_"){
      Barcode.Vector[i] <- paste0("TT",substr(Barcode.Vector[i],3,20))
    }
    if(substr(Barcode.Vector[i],1,2)=="E_"){
      Barcode.Vector[i] <- paste0("AG",substr(Barcode.Vector[i],3,20))
    }
    if(substr(Barcode.Vector[i],1,2)=="F_"){
      Barcode.Vector[i] <- paste0("CT",substr(Barcode.Vector[i],3,20))
    }
    if(substr(Barcode.Vector[i],1,2)=="G_"){
      Barcode.Vector[i] <- paste0("AC",substr(Barcode.Vector[i],3,20))
    }
    i <- i+1
  } 
  return(Barcode.Vector)
}

AAA092.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="AAA092",])
BHC864.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="BHC864",])
FTS963.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="FTS963",])
IND047.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="IND047",])
PPQ901.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="PPQ901",])
QJB196.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="QJB196",])
TLE629.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="TLE629",])
TSS679.Barcodes <- rownames(Tregs@meta.data[Tregs@meta.data$patient_id=="TSS679",])

AAA092.Barcodes <- Immcantation.Input.Barcode.Function(AAA092.Barcodes)
BHC864.Barcodes <- Immcantation.Input.Barcode.Function(BHC864.Barcodes)
FTS963.Barcodes <- Immcantation.Input.Barcode.Function(FTS963.Barcodes)
IND047.Barcodes <- Immcantation.Input.Barcode.Function(IND047.Barcodes)
PPQ901.Barcodes <- Immcantation.Input.Barcode.Function(PPQ901.Barcodes)
QJB196.Barcodes <- Immcantation.Input.Barcode.Function(QJB196.Barcodes)
TLE629.Barcodes <- Immcantation.Input.Barcode.Function(TLE629.Barcodes)
TSS679.Barcodes <- Immcantation.Input.Barcode.Function(TSS679.Barcodes)

write(AAA092.Barcodes,"./Treg Clonality/Immcantation_Input/AAA092.Barcodes.txt")
write(BHC864.Barcodes,"./Treg Clonality/Immcantation_Input/BHC864.Barcodes.txt")
write(FTS963.Barcodes,"./Treg Clonality/Immcantation_Input/FTS963.Barcodes.txt")
write(IND047.Barcodes,"./Treg Clonality/Immcantation_Input/IND047.Barcodes.txt")
write(PPQ901.Barcodes,"./Treg Clonality/Immcantation_Input/PPQ901.Barcodes.txt")
write(QJB196.Barcodes,"./Treg Clonality/Immcantation_Input/QJB196.Barcodes.txt")
write(TLE629.Barcodes,"./Treg Clonality/Immcantation_Input/TLE629.Barcodes.txt")
write(TSS679.Barcodes,"./Treg Clonality/Immcantation_Input/TSS679.Barcodes.txt")

# Preparation of the .csv file
# Read in .csv files from Seurat output.
contigs_lane_A <- read.csv("./Preprocessing Deep Seq/Sample 1/multi_exp027_Lupus_Tregs_Sample_1_DS/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_1_DS/vdj_t/filtered_contig_annotations.csv")
contigs_lane_B <- read.csv("./Preprocessing S4/Cellranger Sample 2/multi_exp027_Lupus_Tregs_Sample_2/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_2/vdj_t/filtered_contig_annotations.csv")
contigs_lane_C <- read.csv("./Preprocessing S4/Cellranger Sample 3/multi_exp027_Lupus_Tregs_Sample_3/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_3/vdj_t/filtered_contig_annotations.csv")  
contigs_lane_D <- read.csv("./Preprocessing S4/Cellranger Sample 4/multi_exp027_Lupus_Tregs_Sample_4/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_4/vdj_t/filtered_contig_annotations.csv")
contigs_lane_E <- read.csv("./Preprocessing Deep Seq 2/Sample 6/multi_exp027_Lupus_Tregs_Sample_6_DS/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_6_DS/vdj_t/filtered_contig_annotations.csv")
contigs_lane_F <- read.csv("./Preprocessing Deep Seq 2/Sample 7/multi_exp027_Lupus_Tregs_Sample_7_DS/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_7_DS/vdj_t/filtered_contig_annotations.csv")
contigs_lane_G <- read.csv("./Preprocessing Deep Seq 2/Sample 8/multi_exp027_Lupus_Tregs_Sample_8_DS/outs/per_sample_outs/multi_exp027_Lupus_Tregs_Sample_8_DS/vdj_t/filtered_contig_annotations.csv")

# Making barcodes unique (as above for .txt files)
contigs_lane_A$barcode <- paste0("AA",contigs_lane_A$barcode)
contigs_lane_B$barcode <- paste0("GG",contigs_lane_B$barcode)
contigs_lane_C$barcode <- paste0("CC",contigs_lane_C$barcode)
contigs_lane_D$barcode <- paste0("TT",contigs_lane_D$barcode)
contigs_lane_E$barcode <- paste0("AG",contigs_lane_E$barcode)
contigs_lane_F$barcode <- paste0("CT",contigs_lane_F$barcode)
contigs_lane_G$barcode <- paste0("AC",contigs_lane_G$barcode)

contigs_lane_A$contig_id <- paste0("AA",contigs_lane_A$contig_id)
contigs_lane_B$contig_id <- paste0("GG",contigs_lane_B$contig_id)
contigs_lane_C$contig_id <- paste0("CC",contigs_lane_C$contig_id)
contigs_lane_D$contig_id <- paste0("TT",contigs_lane_D$contig_id)
contigs_lane_E$contig_id <- paste0("AG",contigs_lane_E$contig_id)
contigs_lane_F$contig_id <- paste0("CT",contigs_lane_F$contig_id)
contigs_lane_G$contig_id <- paste0("AC",contigs_lane_G$contig_id)

# Merging them
all.contigs <- rbind(contigs_lane_A,contigs_lane_B,contigs_lane_C,contigs_lane_D,contigs_lane_E,contigs_lane_F,contigs_lane_G)

# Subset to patient specific objects
AAA092.contigs <- all.contigs[all.contigs$barcode %in% AAA092.Barcodes,]
BHC864.contigs <- all.contigs[all.contigs$barcode %in% BHC864.Barcodes,]
FTS963.contigs <- all.contigs[all.contigs$barcode %in% FTS963.Barcodes,]
IND047.contigs <- all.contigs[all.contigs$barcode %in% IND047.Barcodes,]
PPQ901.contigs <- all.contigs[all.contigs$barcode %in% PPQ901.Barcodes,]
QJB196.contigs <- all.contigs[all.contigs$barcode %in% QJB196.Barcodes,]
TLE629.contigs <- all.contigs[all.contigs$barcode %in% TLE629.Barcodes,]
TSS679.contigs <- all.contigs[all.contigs$barcode %in% TSS679.Barcodes,]

# Writing those to .csv
write_csv(AAA092.contigs, file = "./Treg Clonality/Immcantation_Input/AAA092.Barcodes.csv")
write_csv(BHC864.contigs, file = "./Treg Clonality/Immcantation_Input/BHC864.Barcodes.csv")
write_csv(FTS963.contigs, file = "./Treg Clonality/Immcantation_Input/FTS963.Barcodes.csv")
write_csv(IND047.contigs, file = "./Treg Clonality/Immcantation_Input/IND047.Barcodes.csv")
write_csv(PPQ901.contigs, file = "./Treg Clonality/Immcantation_Input/PPQ901.Barcodes.csv")
write_csv(QJB196.contigs, file = "./Treg Clonality/Immcantation_Input/QJB196.Barcodes.csv")
write_csv(TLE629.contigs, file = "./Treg Clonality/Immcantation_Input/TLE629.Barcodes.csv")
write_csv(TSS679.contigs, file = "./Treg Clonality/Immcantation_Input/TSS679.Barcodes.csv")

remove(contigs_lane_A,contigs_lane_B,contigs_lane_C,contigs_lane_D,contigs_lane_E,contigs_lane_F,contigs_lane_G,AAA092.Barcodes,AAA092.contigs,
       BHC864.contigs,BHC864.Barcodes,FTS963.contigs,FTS963.Barcodes,IND047.contigs,IND047.Barcodes,PPQ901.Barcodes,PPQ901.contigs,QJB196.Barcodes,QJB196.contigs,
       TLE629.Barcodes,TLE629.contigs,TSS679.Barcodes,TSS679.contigs,all.contigs)

########################################################################################################################################################################
# Part 3: Analysis of Immcantation Output and adding the output back to the Seurat object
########################################################################################################################################################################
# Loading Immcantation Output files
AAA092.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/AAA092.Barcodes/outputs/AAA092.Barcodes_0/AAA092.Barcodes_0_heavy_germ-pass.tsv"))
BHC864.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/BHC864.Barcodes/outputs/BHC864.Barcodes_0/BHC864.Barcodes_0_heavy_germ-pass.tsv"))
FTS963.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/FTS963.Barcodes/outputs/FTS963.Barcodes_0/FTS963.Barcodes_0_heavy_germ-pass.tsv"))
IND047.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/IND047.Barcodes/outputs/IND047.Barcodes_0/IND047.Barcodes_0_heavy_germ-pass.tsv"))
PPQ901.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/PPQ901.Barcodes/outputs/PPQ901.Barcodes_0/PPQ901.Barcodes_0_heavy_germ-pass.tsv"))
QJB196.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/QJB196.Barcodes/outputs/QJB196.Barcodes_0/QJB196.Barcodes_0_heavy_germ-pass.tsv"))
TLE629.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/TLE629.Barcodes/outputs/TLE629.Barcodes_0/TLE629.Barcodes_0_heavy_germ-pass.tsv"))
TSS679.Immcantation_output <- as.data.frame(read_airr("~/NAS/Jan/Experiments and Data/210310 - Exp 027 - Lupus collaboration/Treg Run 102022/Treg Clonality/Output_data/TSS679.Barcodes/outputs/TSS679.Barcodes_0/TSS679.Barcodes_0_heavy_germ-pass.tsv"))

# Generating a column that shows clonal expansion
Immcantation.Output.List <- list(AAA092.Immcantation_output,BHC864.Immcantation_output,FTS963.Immcantation_output,IND047.Immcantation_output,
                                 PPQ901.Immcantation_output,QJB196.Immcantation_output,TLE629.Immcantation_output,TSS679.Immcantation_output)
Immcantation.Output.List <- map(Immcantation.Output.List, function(df) {
  df %>%
    group_by(clone_id) %>%
    mutate(Clonesize = n())
})
Immcantation.Output.List <- map(Immcantation.Output.List, as.data.frame)

# In order to be able to merge the Immcantation output with the Seurat object, I need to change
# the cell barcodes in the Immcantation output back to the nomenclature that is used in the Seurat
# object. (Basically doing backwards what was done to prepare the Immcantation input files.)
Reverse.Immcantation.Input.Barcode.Function <- function(Barcode.Vector){
  for (i in 1:length(Barcode.Vector)) {
    if(substr(Barcode.Vector[i], 1, 2) == "AA"){
      Barcode.Vector[i] <- paste0("A_", substr(Barcode.Vector[i], 3, 20))
    }
    if(substr(Barcode.Vector[i], 1, 2) == "GG"){
      Barcode.Vector[i] <- paste0("B_", substr(Barcode.Vector[i], 3, 20))
    }
    if(substr(Barcode.Vector[i], 1, 2) == "CC"){
      Barcode.Vector[i] <- paste0("C_", substr(Barcode.Vector[i], 3, 20))
    }
    if(substr(Barcode.Vector[i], 1, 2) == "TT"){
      Barcode.Vector[i] <- paste0("D_", substr(Barcode.Vector[i], 3, 20))
    }
    if(substr(Barcode.Vector[i], 1, 2) == "AG"){
      Barcode.Vector[i] <- paste0("E_", substr(Barcode.Vector[i], 3, 20))
    }
    if(substr(Barcode.Vector[i], 1, 2) == "CT"){
      Barcode.Vector[i] <- paste0("F_", substr(Barcode.Vector[i], 3, 20))
    }
    if(substr(Barcode.Vector[i], 1, 2) == "AC"){
      Barcode.Vector[i] <- paste0("G_", substr(Barcode.Vector[i], 3, 20))
    }
  } 
  return(Barcode.Vector)
}
Immcantation.Output.List <- map(Immcantation.Output.List, function(df) {
  df$cell_id <- Reverse.Immcantation.Input.Barcode.Function(df$cell_id)
  return(df)
})

# Adding a prefix to all clones from each patient to make them definitely unique
Immcantation.Output.List <- map2(Immcantation.Output.List, seq_along(Immcantation.Output.List), function(df, index) {
  df %>% mutate(clone_id = paste0(index, "_", clone_id))
})

# Putting the cell IDs as row names
Immcantation.Output.List <- map(Immcantation.Output.List, function(df) {
  rownames(df) <- df$cell_id
  df
})

# Binding individual output files
Immcantation_Output <- do.call(rbind, Immcantation.Output.List)

remove(AAA092.Immcantation_output,BHC864.Immcantation_output,FTS963.Immcantation_output,Immcantation.Output.List,IND047.Immcantation_output,
       PPQ901.Immcantation_output,QJB196.Immcantation_output,TLE629.Immcantation_output,TSS679.Immcantation_output)

# Merging the Immcantation.Output df to the metadata of the Treg Seurat object for further downstream analysis
Tregs@meta.data <- merge(Tregs@meta.data,Immcantation_Output[,c("cdr3","clone_id","Clonesize")],by=0, all.x=T)
rownames(Tregs@meta.data) <- Tregs@meta.data$Row.names
Tregs@meta.data$clone_id_v <- paste0(Tregs@meta.data$timepoint,"_",Tregs@meta.data$clone_id)

# The following has to be done because otherwise cells which don't have a clone ID accidentally get 
# a clone ID "V2_NA" or "V3_NA" in the clone_id_v column as a result of the cbind command from earlier. 
Tregs@meta.data$clone_id_v[Tregs@meta.data$clone_id_v=="V2_NA"] <- NA
Tregs@meta.data$clone_id_v[Tregs@meta.data$clone_id_v=="V3_NA"] <- NA
remove(Immcantation_Output)
#save(Tregs,file="Tregs.rds")

########################################################################################################################################################################
# Part 4: Downstream TCR clonal analysis
########################################################################################################################################################################
# In time points V2 and V3 separately, looking at clonal overlaps with an upset plot.
V2 <- Tregs@meta.data[Tregs@meta.data$timepoint=="V2"&!is.na(Tregs@meta.data$Clonesize),]
V3 <- Tregs@meta.data[Tregs@meta.data$timepoint=="V3"&!is.na(Tregs@meta.data$Clonesize),]

# Now (after subsetting) there are some clones with changed frequency (all longitudinal clones), 
# so we need to update the Clonesize column.
V2 <- V2 %>%
  group_by(clone_id) %>%
  mutate(Clonesize = n())
V3 <- V3 %>%
  group_by(clone_id) %>%
  mutate(Clonesize = n())

# Subsetting to expanded clones.
V2 <- V2[V2$Clonesize > 1,]
V3 <- V3[V3$Clonesize > 1,]

V2_CD38_positive <- V2$clone_id[V2$Treg_subclusters=="CD38+ Tregs"]
V2_Double_positive <- V2$clone_id[V2$Treg_subclusters=="HLA-DR+ CD38+ Tregs"]
V2_HLA_DR_positive <- V2$clone_id[V2$Treg_subclusters=="HLA-DR+ Tregs"] 
V2_Resting_Tregs <- V2$clone_id[V2$Treg_subclusters=="resting Tregs"]
V2_naive_Tregs <- V2$clone_id[V2$Treg_subclusters=="naive Tregs"]

V3_CD38_positive <- V3$clone_id[V3$Treg_subclusters=="CD38+ Tregs"]
V3_Double_positive <- V3$clone_id[V3$Treg_subclusters=="HLA-DR+ CD38+ Tregs"]
V3_HLA_DR_positive <- V3$clone_id[V3$Treg_subclusters=="HLA-DR+ Tregs"]
V3_Resting_Tregs <- V3$clone_id[V3$Treg_subclusters=="resting Tregs"]
V3_naive_Tregs <- V3$clone_id[V3$Treg_subclusters=="naive Tregs"]  

V2_list = list(V2_CD38_positive=V2_CD38_positive,
               V2_Double_positive=V2_Double_positive,
               V2_HLA_DR_positive=V2_HLA_DR_positive,
               V2_Resting_Tregs=V2_Resting_Tregs,
               V2_naive_Tregs=V2_naive_Tregs)

V3_list = list(V3_CD38_positive=V3_CD38_positive,
               V3_Double_positive=V3_Double_positive,
               V3_HLA_DR_positive=V3_HLA_DR_positive,
               V3_Resting_Tregs=V3_Resting_Tregs,
               V3_naive_Tregs=V3_naive_Tregs)

V2_m <- make_comb_mat(V2_list)
V3_m <- make_comb_mat(V3_list)
set_name(V2_m) <- c("V2_CD38_positive","V2_Double_positive", "V2_HLA_DR_positive", "V2_Resting_Tregs","V2_naive_Tregs")
set_name(V3_m) <- c("V3_CD38_positive","V3_Double_positive", "V3_HLA_DR_positive", "V3_Resting_Tregs","V3_naive_Tregs")

# How to read Upset Plot:
# Sum over all columns = number of clones
# Rows = Number of clones with that subset
# The number of cells is not visible in the plot.
# Export 5x8
UpSet(V2_m[comb_size(V2_m) <= 500],top_annotation = upset_top_annotation(V2_m[comb_size(V2_m) <= 500], ylim = c(0, 200), add_numbers = TRUE),
      right_annotation = upset_right_annotation(V2_m[comb_size(V2_m) <= 500], ylim=c(0,330), add_numbers = TRUE))

UpSet(V3_m[comb_size(V3_m) <= 500],top_annotation = upset_top_annotation(V3_m[comb_size(V3_m) <= 500], ylim = c(0, 200), add_numbers = TRUE),
      right_annotation = upset_right_annotation(V3_m[comb_size(V3_m) <= 500], ylim=c(0,330), add_numbers = TRUE))


remove(V2_m, V3_m, V2_list, V3_list, V2, V3,V2_CD38_positive,V2_Double_positive,V2_HLA_DR_positive,V2_naive_Tregs,V2_Resting_Tregs,
       V3_CD38_positive,V3_Double_positive,V3_HLA_DR_positive,V3_naive_Tregs,V3_Resting_Tregs)



# Expansion numbers of clones on individual patient level and comparing the time points
V2 <- Tregs@meta.data[Tregs@meta.data$timepoint=="V2"&!is.na(Tregs@meta.data$Clonesize),
                      c("patient_id","Treg_subclusters","clone_id","Clonesize","timepoint")]
V3 <- Tregs@meta.data[Tregs@meta.data$timepoint=="V3"&!is.na(Tregs@meta.data$Clonesize),
                      c("patient_id","Treg_subclusters","clone_id","Clonesize","timepoint")]

# The following section is only needed if naive Tregs are kicked. Default: Naive Tregs are not kicked.
#Keepers <- c("CD38+ Tregs","HLA-DR+ CD38+ Tregs","HLA-DR+ Tregs","resting Tregs")
#V2 <- V2[V2$Treg_subclusters %in% Keepers,]
#V3 <- V3[V3$Treg_subclusters %in% Keepers,]
#remove(Keepers)
#V2 <- droplevels(V2)
#V3 <- droplevels(V3)

# Correcting the clone size column after subsetting
V2 <- V2 %>%
  group_by(clone_id) %>%
  mutate(Clonesize = n()) %>% ungroup
V3 <- V3 %>%
  group_by(clone_id) %>%
  mutate(Clonesize = n()) %>% ungroup

V2 <- as.data.frame(V2)
V3 <- as.data.frame(V3)

# Adding a column which tells us what the percentage of expanded clones is
V2$expanded <- "no"
V3$expanded <- "no"
V2$expanded[V2$Clonesize>1] <- "yes"
V3$expanded[V3$Clonesize>1] <- "yes"

# Dividing to patient level, calculating percentages and plotting the result
V2.list <- V2 %>% dplyr::group_by(patient_id) %>% group_split()
V3.list <- V3 %>% dplyr::group_by(patient_id) %>% group_split()

V2.percentages <- c()
V3.percentages <- c()
for (i in 1:length(V2.list)) {
  V2.percentages[i] <- round(100*length(unique(V2.list[[i]]$clone_id[V2.list[[i]]$expanded=="yes"]))/length(unique(V2.list[[i]]$clone_id)),1)
}

for (i in 1:length(V3.list)) {
  V3.percentages[i] <- round(100*length(unique(V3.list[[i]]$clone_id[V3.list[[i]]$expanded=="yes"]))/length(unique(V3.list[[i]]$clone_id)),1)
}

df <- cbind(V2.percentages,V3.percentages)
df <- melt(df)

# Export 5x6
# The only patient in which we see a decrease in Treg clonal expansion is BHC864.
ggpaired(df, x = "Var2", y = "value",
         line.color = "black", line.size = 0.4,palette = c('#999999','#E69F00'),fill="Var2")+
  stat_compare_means(paired = TRUE)+xlab("")+ylab("Expanded clones (%)")+ labs(color="Timepoint")+labs(fill="")+
  theme(legend.position = "right")+ggtitle("Expanded clones per timepoint (%) \n Paired analysis on patient level")+center.title()

write.xlsx(df,"Expanded_clones_per_timepoint_paired.xlsx")
remove(df,V2.list,V3.list,V2,V3,i,V2.percentages,V3.percentages)



# Circos plot. 
# Segment connections DN-any other are blue.
# Specify which time point should be used! (V2/V3)
V2 <- Tregs@meta.data[!is.na(Tregs@meta.data$clone_id)& 
                        Tregs@meta.data$timepoint=="V2",c("clone_id","Treg_subclusters")]
V2 <- V2 %>% arrange(factor(V2$Treg_subclusters, levels = levels(V2$Treg_subclusters)),clone_id)
V2$Ring_Coordinate <- 1:nrow(V2)
df <- data.frame(table(V2$Treg_subclusters))
df$cumsum <- cumsum(df$Freq)
sectors <- c(unique(df$Var1))
Matrix <- matrix(1:10, nrow = 5, ncol = 2)
rownames(Matrix) <- sectors

Matrix[1,] <- c(0,df[1,3])
Matrix[2,] <- c(df[1,3]+1,df[2,3])
Matrix[3,] <- c(df[2,3]+1,df[3,3])
Matrix[4,] <- c(df[3,3]+1,df[4,3]) 
Matrix[5,] <- c(df[4,3]+1,df[5,3]) 

circos.initialize(sectors = sectors, xlim = Matrix)

circos.track(ylim=c(0,1), bg.col=c("#DBC35E","#AA3377","#c2c1c0","#4477AA","#228833"))
circos.text(mean(c(0,df[1,3])), 1.5, "HLA-DR+ CD38+", sector.index = "HLA-DR+ CD38+ Tregs", track.index = 1,cex=0.7, facing = "bending")
circos.text(mean(c(df[1,3]+1,df[2,3])), 1.5, "CD38+ Tregs", sector.index = "CD38+ Tregs", track.index = 1,cex=0.7, facing = "bending")
circos.text(mean(c(df[2,3]+1,df[3,3])), 1.5, "HLA-DR+ Tregs", sector.index = "HLA-DR+ Tregs", track.index = 1,cex=0.7, facing = "bending")
circos.text(mean(c(df[3,3]+1,df[4,3])), 1.5, "resting Tregs", sector.index = "resting Tregs", track.index = 1,cex=0.7, facing = "bending")
circos.text(mean(c(df[4,3]+1,df[5,3])), 1.5, "naive Tregs", sector.index = "naive Tregs", track.index = 1,cex=0.7, facing = "bending")

# Now the cross links are added step by step in an automated, generalized way.
# The loop will run as many times as we have clones in the subsetted dataset.
# In each iteration, the loop looks at a different clone.
# First, it checks whether the clone is a cross subset clone. If it is not, the loop directly 
# goes to the next iteration.
# Next, it checks how many different subsets are present.
# 2 subsets --> one connection needed
# 3 subsets --> three connections needed
# 4 subsets --> six connections needed
# The number of connections determines the number of times the circos.link command is called.
# Possible 10 connections (Loop has to check for each of them to be present):
# resting - HLA-DR-pos
# resting - CD38-pos
# resting - HLA-DR-CD38-pos
# resting - naive
# HLA-DR-pos - CD38-pos
# HLA-DR-pos - HLA-DR-CD38-pos
# HLA-DR-pos - naive
# CD38-pos - HLA-DR-CD38-pos
# CD38-pos - naive
# HLA-DR-CD38-pos - naive
# So inside the loop step, a dataframe is created that contains the information which 
# connections are to be made for this clone.
clonelist <- c(unique(V2$clone_id))
connections.df.collection <- data.frame("Connection_ID"="","First_segment"="","Connection_Beginning"="","Second_segment"="","Connection_End"="")

for (i in 1:length(unique(V2$clone_id))) {
  
  this.rounds.clone <- clonelist[i]
  this.rounds.clone.df <- V2[V2$clone_id %in% this.rounds.clone,]
  if(length(unique(this.rounds.clone.df$Treg_subclusters))==1){
    next
  } else {
    
    number.of.subsets <- length(unique(this.rounds.clone.df$Treg_subclusters))
    if(number.of.subsets==2){number.of.connections <- 1}
    if(number.of.subsets==3){number.of.connections <- 3}
    if(number.of.subsets==4){number.of.connections <- 5}
    
    connections.df <- data.frame("Connection_ID"=c(1:length(number.of.connections)),"First_segment"="","Connection_Beginning"="","Second_segment"="","Connection_End"="")
    
    # Generate all possible pairings without repetition
    pairings.df <- unique(data.frame(t(combn(as.character(unique(this.rounds.clone.df$Treg_subclusters)), 2))))
    
    # Loop to generate the connections.df
    for(x in 1:nrow(pairings.df)){
      connections.df[x,"First_segment"] <- pairings.df[x,1]
      connections.df[x,"Second_segment"] <- pairings.df[x,2]
      connections.df[x,"Connection_Beginning"] <- paste(c(this.rounds.clone.df$Ring_Coordinate[this.rounds.clone.df$Treg_subclusters==connections.df$First_segment[x]]),collapse = ", ")
      connections.df[x,"Connection_End"] <- paste(c(this.rounds.clone.df$Ring_Coordinate[this.rounds.clone.df$Treg_subclusters==connections.df$Second_segment[x]]),collapse = ", ")
    }
    connections.df.collection <- rbind(connections.df.collection,connections.df)
    # Finally, the connections are made using the circos.link command
    # The circos.link command has to be run the number of times as connections have to be made. I will use another for loop for this
    for (v in 1:nrow(connections.df)) {
      
      connection.start <- as.numeric(unlist(strsplit(connections.df$Connection_Beginning[v], ",")))
      connection.end <- as.numeric(unlist(strsplit(connections.df$Connection_End[v],",")))
      connection.start <- c(min(connection.start),max(connection.start))
      connection.end <- c(min(connection.end),max(connection.end))
      
      circos.link(sector.index1=connections.df$First_segment[v],
                  connection.start,
                  sector.index2=connections.df$Second_segment[v],
                  connection.end,
                  lwd=0.5,
                  col = if("resting Tregs" %in% connections.df$First_segment[v]|
                           "resting Tregs" %in% connections.df$Second_segment[v]){"#4477AA"}
                  else {"black"})
    }
  }
}
title(main="V2")

remove(connection.end,connection.start,connections.df,Matrix,pairings.df,this.rounds.clone,this.rounds.clone.df,
       V2,clonelist,i,number.of.connections,number.of.subsets,x,v,sectors,df,connections.df.collection)



# Plotting subset clonal overlap for each time point. Treat patients as samples, take all clones into account.
V2 <- Tregs@meta.data[Tregs@meta.data$timepoint=="V2"&!is.na(Tregs@meta.data$Clonesize),
                      c("patient_id","Treg_subclusters","clone_id","Clonesize","timepoint")]
V3 <- Tregs@meta.data[Tregs@meta.data$timepoint=="V3"&!is.na(Tregs@meta.data$Clonesize),
                      c("patient_id","Treg_subclusters","clone_id","Clonesize","timepoint")]
Keepers <- c("CD38+ Tregs","HLA-DR+ CD38+ Tregs","HLA-DR+ Tregs","resting Tregs") # --> Kicking out naive Tregs
V2 <- V2[V2$Treg_subclusters %in% Keepers,]
V3 <- V3[V3$Treg_subclusters %in% Keepers,]
remove(Keepers)
V2 <- droplevels(V2)
V3 <- droplevels(V3)

# Correcting the clone size column after subsetting
V2 <- V2 %>%
  group_by(clone_id) %>%
  mutate(Clonesize = n()) %>% ungroup
V3 <- V3 %>%
  group_by(clone_id) %>%
  mutate(Clonesize = n()) %>% ungroup

# Adding six columns, one for each subset crossing possibility
V2$resting_Tregs_and_CD38_pos_Tregs <- "No"
V2$resting_Tregs_and_HLA_DR_pos_Tregs <- "No"
V2$resting_Tregs_and_double_pos_Tregs <- "No"
V2$CD38_pos_Tregs_and_HLA_DR_pos_Tregs <- "No"
V2$CD38_pos_Tregs_and_double_pos_Tregs <- "No"
V2$HLA_DR_pos_Tregs_and_double_pos_Tregs <- "No"

V3$resting_Tregs_and_CD38_pos_Tregs <- "No"
V3$resting_Tregs_and_HLA_DR_pos_Tregs <- "No"
V3$resting_Tregs_and_double_pos_Tregs <- "No"
V3$CD38_pos_Tregs_and_HLA_DR_pos_Tregs <- "No"
V3$CD38_pos_Tregs_and_double_pos_Tregs <- "No"
V3$HLA_DR_pos_Tregs_and_double_pos_Tregs <- "No"

# Putting "yes" to the correct rows for each of these columns.
V2.clones <- unique(V2$clone_id)
V3.clones <- unique(V3$clone_id)

for (i in 1:length(V2.clones)) {
  this.rounds.clone <- V2.clones[i]
  V2.subset <- as.character(V2$Treg_subclusters[V2$clone_id %in% this.rounds.clone])
  
  if("resting Tregs" %in% V2.subset & "CD38+ Tregs" %in% V2.subset){
    V2$resting_Tregs_and_CD38_pos_Tregs[V2$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("resting Tregs" %in% V2.subset & "HLA-DR+ Tregs" %in% V2.subset){
    V2$resting_Tregs_and_HLA_DR_pos_Tregs[V2$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("resting Tregs" %in% V2.subset & "HLA-DR+ CD38+ Tregs" %in% V2.subset){
    V2$resting_Tregs_and_double_pos_Tregs[V2$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("CD38+ Tregs" %in% V2.subset & "HLA-DR+ Tregs" %in% V2.subset){
    V2$CD38_pos_Tregs_and_HLA_DR_pos_Tregs[V2$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("CD38+ Tregs" %in% V2.subset & "HLA-DR+ CD38+ Tregs" %in% V2.subset){
    V2$CD38_pos_Tregs_and_double_pos_Tregs[V2$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("HLA-DR+ Tregs" %in% V2.subset & "HLA-DR+ CD38+ Tregs" %in% V2.subset){
    V2$HLA_DR_pos_Tregs_and_double_pos_Tregs[V2$clone_id %in% this.rounds.clone] <- "Yes"
  }
}
remove(i)

for (i in 1:length(V3.clones)) {
  this.rounds.clone <- V3.clones[i]
  V3.subset <- as.character(V3$Treg_subclusters[V3$clone_id %in% this.rounds.clone])
  
  if("resting Tregs" %in% V3.subset & "CD38+ Tregs" %in% V3.subset){
    V3$resting_Tregs_and_CD38_pos_Tregs[V3$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("resting Tregs" %in% V3.subset & "HLA-DR+ Tregs" %in% V3.subset){
    V3$resting_Tregs_and_HLA_DR_pos_Tregs[V3$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("resting Tregs" %in% V3.subset & "HLA-DR+ CD38+ Tregs" %in% V3.subset){
    V3$resting_Tregs_and_double_pos_Tregs[V3$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("CD38+ Tregs" %in% V3.subset & "HLA-DR+ Tregs" %in% V3.subset){
    V3$CD38_pos_Tregs_and_HLA_DR_pos_Tregs[V3$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("CD38+ Tregs" %in% V3.subset & "HLA-DR+ CD38+ Tregs" %in% V3.subset){
    V3$CD38_pos_Tregs_and_double_pos_Tregs[V3$clone_id %in% this.rounds.clone] <- "Yes"
  }
  if("HLA-DR+ Tregs" %in% V3.subset & "HLA-DR+ CD38+ Tregs" %in% V3.subset){
    V3$HLA_DR_pos_Tregs_and_double_pos_Tregs[V3$clone_id %in% this.rounds.clone] <- "Yes"
  }
}
remove(i)

# Splitting to patient level
V2.list <- V2 %>% dplyr::group_by(patient_id) %>% group_split()
V3.list <- V3 %>% dplyr::group_by(patient_id) %>% group_split()

# Calculating percentages
V2.list <- map(V2.list, function(df) {
  df$Treg_subclusters <- NULL
  df <- unique(df)
  df$resting_Tregs_and_CD38_pos_Tregs <- 100*(nrow(df[df$resting_Tregs_and_CD38_pos_Tregs=="Yes",])/nrow(df))
  df$resting_Tregs_and_HLA_DR_pos_Tregs <- 100*(nrow(df[df$resting_Tregs_and_HLA_DR_pos_Tregs=="Yes",])/nrow(df))
  df$resting_Tregs_and_double_pos_Tregs <- 100*(nrow(df[df$resting_Tregs_and_double_pos_Tregs=="Yes",])/nrow(df))
  df$CD38_pos_Tregs_and_HLA_DR_pos_Tregs <- 100*(nrow(df[df$CD38_pos_Tregs_and_HLA_DR_pos_Tregs=="Yes",])/nrow(df))
  df$CD38_pos_Tregs_and_double_pos_Tregs <- 100*(nrow(df[df$CD38_pos_Tregs_and_double_pos_Tregs=="Yes",])/nrow(df))
  df$HLA_DR_pos_Tregs_and_double_pos_Tregs <- 100*(nrow(df[df$HLA_DR_pos_Tregs_and_double_pos_Tregs=="Yes",])/nrow(df))
  df$clone_id <- NULL
  df$Clonesize <- NULL
  df <- unique(df)
})
V3.list <- map(V3.list, function(df) {
  df$Treg_subclusters <- NULL
  df <- unique(df)
  df$resting_Tregs_and_CD38_pos_Tregs <- 100*(nrow(df[df$resting_Tregs_and_CD38_pos_Tregs=="Yes",])/nrow(df))
  df$resting_Tregs_and_HLA_DR_pos_Tregs <- 100*(nrow(df[df$resting_Tregs_and_HLA_DR_pos_Tregs=="Yes",])/nrow(df))
  df$resting_Tregs_and_double_pos_Tregs <- 100*(nrow(df[df$resting_Tregs_and_double_pos_Tregs=="Yes",])/nrow(df))
  df$CD38_pos_Tregs_and_HLA_DR_pos_Tregs <- 100*(nrow(df[df$CD38_pos_Tregs_and_HLA_DR_pos_Tregs=="Yes",])/nrow(df))
  df$CD38_pos_Tregs_and_double_pos_Tregs <- 100*(nrow(df[df$CD38_pos_Tregs_and_double_pos_Tregs=="Yes",])/nrow(df))
  df$HLA_DR_pos_Tregs_and_double_pos_Tregs <- 100*(nrow(df[df$HLA_DR_pos_Tregs_and_double_pos_Tregs=="Yes",])/nrow(df))
  df$clone_id <- NULL
  df$Clonesize <- NULL
  df <- unique(df)
})

# Merging again to one df
V2 <- do.call(rbind, V2.list)
V3 <- do.call(rbind, V3.list)
Overlap <- rbind(V2,V3)
Overlap$cross.subset.clone <- NULL
Overlap <- reshape2::melt(Overlap, id = c("patient_id","timepoint"))
Overlap <- Overlap %>% group_by(patient_id)

# Statistical test for comparisons of time points (per subset cross).
stat.test <- Overlap %>% 
  group_by(variable) %>% 
  rstatix::wilcox_test(value~timepoint,comparisons = c("V2","V3"),paired = F)

stat.test$asterics <- ""
for (i in 1:nrow(stat.test)) {
  stat.test$asterics[i] <- asterics.function(stat.test$p[i])
}

# Plotting
ggpaired(Overlap, x = "timepoint", y = "value",
         fill = "timepoint",id="patient_id", 
         line.color = "black", line.size = 0.4,palette=c("#999999", "#E69F00"),
         facet.by = "variable")+stat_pvalue_manual(stat.test, label = "asterics", y.position = c(3))+
  xlab("")+ylab("Fraction of clones with respective subset overlap (%)")+labs(fill="Time point")+theme(legend.position = "bottom")

remove(Overlap,stat.test,V2,V3,V2.list,V3.list,i,this.rounds.clone,V2.clones,V3.clones,V2.subset,V3.subset)


